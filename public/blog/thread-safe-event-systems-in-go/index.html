<!DOCTYPE html>
<html lang="en-us">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Thread-Safe Event Systems in Go: A k6 waitForResponse Case Study | &gt; Hasith De Alwis</title>
    <style>
        <nav><a href="/" {
                {
                if .IsHome
            }
        }

        class="active" {
                {
                end
            }
        }

        >[ home]</a><a href="/blog/" {
                {
                if eq .Section "blog"
            }
        }

        class="active" {
                {
                end
            }
        }

        >[ blog]</a><a href="/projects/" {
                {
                if eq .Section "projects"
            }
        }

        class="active" {
                {
                end
            }
        }

        >[ projects]</a></nav>* {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            line-height: 1.6;
            background-color: #f8f9fa;
            color: #2d3748;
            font-size: 14px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }

        header {
            background-color: #404040;
            color: #ffffff;
            padding: 20px 40px;
            border-bottom: 3px solid #333;
        }

        .header-title {
            font-size: 24px;
            font-weight: normal;
            margin-bottom: 10px;
        }

        .header-title a {
            color: #ffffff;
            text-decoration: none;
        }

        .header-title a:hover {
            color: #87ceeb;
        }

        .header-subtitle {
            color: #b0b0b0;
            font-size: 16px;
            margin-bottom: 15px;
        }

        nav {
            margin-top: 10px;
        }

        nav a {
            color: #87ceeb;
            text-decoration: none;
            margin-right: 25px;
            padding: 5px 10px;
            border: 1px solid transparent;
            font-size: 14px;
        }

        nav a:hover,
        nav a.active {
            background-color: #333;
            border: 1px solid #555;
            color: #ffffff;
        }

        main {
            padding: 40px;
            min-height: calc(100vh - 200px);
        }

        .content h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #2d3748;
            font-weight: normal;
        }

        .content h2 {
            font-size: 20px;
            margin: 0 0 15px 0;
            color: #4a5568;
            font-weight: normal;
        }

        .content h3 {
            font-size: 16px;
            margin: 25px 0 10px 0;
            color: #4a5568;
            font-weight: normal;
        }

        .content p {
            margin-bottom: 15px;
            line-height: 1.7;
        }

        .content ul {
            margin: 15px 0 15px 30px;
        }

        .content li {
            margin-bottom: 8px;
        }

        .content a {
            color: #3182ce;
            text-decoration: underline;
        }

        .content a:hover {
            color: #2c5282;
        }

        .post-meta {
            color: #718096;
            font-size: 12px;
            margin-bottom: 15px;
            font-style: italic;
        }

        .post-list {
            margin-top: 30px;
        }

        .post-item {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .post-item:last-child {
            border-bottom: none;
        }

        .post-title {
            margin: 0 0 8px 0;
            font-size: 18px;
        }

        .post-title a {
            text-decoration: none;
            color: #2d3748;
        }

        .post-title a:hover {
            color: #3182ce;
            text-decoration: underline;
        }

        .project-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 25px;
        }

        .project-card {
            border: 1px solid #e2e8f0;
            padding: 20px;
            background-color: #f7fafc;
        }

        .project-card h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2d3748;
        }

        .project-card p {
            margin-bottom: 15px;
            font-size: 13px;
            line-height: 1.6;
        }

        .project-links a {
            display: inline-block;
            margin-right: 15px;
            color: #3182ce;
            text-decoration: none;
            font-size: 12px;
            border: 1px solid #3182ce;
            padding: 4px 8px;
        }

        .project-links a:hover {
            background-color: #3182ce;
            color: white;
        }

        .hero-section {
            margin-bottom: 40px;
            padding: 10px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .hero-section h1 {
            font-size: 32px;
            margin-bottom: 15px;
            color: #2d3748;
        }

        .hero-section p {
            font-size: 16px;
            color: #4a5568;
            margin-bottom: 10px;
        }

        footer {
            background-color: #404040;
            color: #b0b0b0;
            text-align: center;
            padding: 20px;
            font-size: 12px;
            border-top: 3px solid #333;
        }

        .social-links {
            margin: 15px 0;
        }

        .social-links a {
            color: #87ceeb;
            text-decoration: none;
            margin: 0 15px;
            font-size: 13px;
        }

        .social-links a:hover {
            color: #ffffff;
        }

        .status-line {
            background-color: #333;
            color: #87ceeb;
            padding: 8px 40px;
            font-size: 12px;
            border-top: 1px solid #555;
        }

        code {
            background-color: #f1f5f9;
            padding: 2px 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #e53e3e;
        }

        pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .blog-banner {
            background-color: #404040;
            color: #ffffff;
            padding: 40px 0;
            margin: 0;
            width: 100%;
        }

        .blog-banner-content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 40px;
        }

        .blog-banner h1 {
            font-size: 32px;
            margin: 0 0 10px 0;
            color: #ffffff;
            font-weight: normal;
        }

        .blog-banner .post-meta {
            color: #b0b0b0;
            font-size: 14px;
            font-style: italic;
        }

        .blog-post {
            margin: 0;
            padding: 0;
        }

        .blog-content {
            padding: 40px;
            max-width: 1000px;
            margin: 0 auto;
        }

        .blog-content article {
            margin: 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="header-title">
                <a href="/">&gt; Hasith De Alwis</a>
            </div>
            <div class="header-subtitle">
                <h1>I'm a builder</h1>
            </div>
            <nav>
                <a href="/" >[ home ]</a>
                <a href="/blog/" class="active" >[ blog ]</a>
                <a href="/projects/" >[ projects ]</a>
            </nav>
        </header>

        <main>
            
<style>
    code {
        background-color: transparent;
    }
</style>


<div class="blog-post">
    <div class="blog-banner">
        <div class="blog-banner-content">
            <h1>Building Thread-Safe Event Systems in Go: A k6 waitForResponse Case Study</h1>
            <div class="post-meta">
                Published on July 24, 2025
            </div>
        </div>
    </div>
    <div class="blog-content">
        <article>
            <div class="content">
                <h1 id="building-thread-safe-event-systems-in-go-a-k6-waitforresponse-case-study">Building Thread-Safe Event Systems in Go: A k6 waitForResponse Case Study</h1>
<p>Browser automation tools need to wait for specific network responses—but building this in a concurrent system is trickier than it looks. When testing web applications, you often need to wait for an API call to complete before proceeding with the next action. Without proper synchronization, tests become flaky and unreliable. Recently, I contributed the <code>waitForResponse</code> API to k6&rsquo;s browser module, architecting a thread-safe event system that handles hundreds of concurrent waiters without race conditions or resource leaks.</p>
<h2 id="the-problem-reflection-hell">The Problem: Reflection Hell</h2>
<p>The initial approach used k6&rsquo;s generic event handler system with reflection-based cleanup. Here&rsquo;s what the problematic code looked like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Page</span>) <span style="color:#a6e22e">WaitForResponse</span>(<span style="color:#f92672">...</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Manually add handler to generic event system</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">eventHandlers</span>[<span style="color:#a6e22e">EventPageResponseCalled</span>] = append(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">eventHandlers</span>[<span style="color:#a6e22e">EventPageResponseCalled</span>], <span style="color:#a6e22e">handler</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Complex reflection-based cleanup</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">handlers</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">h</span>).<span style="color:#a6e22e">Pointer</span>() <span style="color:#f92672">==</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">handler</span>).<span style="color:#a6e22e">Pointer</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">handlers</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">handlers</span>[len(<span style="color:#a6e22e">handlers</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">eventHandlers</span>[<span style="color:#a6e22e">EventPageResponseCalled</span>] = <span style="color:#a6e22e">handlers</span>[:len(<span style="color:#a6e22e">handlers</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This approach had serious issues: race conditions when multiple goroutines modified the handler slice, resource leaks when cleanup failed, and reflection-based pointer comparisons that were fragile and hard to debug. The generic event system wasn&rsquo;t designed for the specific needs of blocking operations with automatic cleanup.</p>
<h2 id="design-requirements-what-success-looks-like">Design Requirements: What Success Looks Like</h2>
<p>The replacement system needed to handle several critical requirements. First, thread-safe concurrent access—multiple goroutines should be able to register waiters simultaneously without corruption. Second, automatic resource cleanup—no manual tracking of handler instances or complex reflection logic. Third, efficient pattern matching for URL filtering using both string matches and regex patterns. Finally, seamless integration with k6&rsquo;s existing context cancellation and timeout systems. The solution needed to handle edge cases like timeouts and context cancellation gracefully while maintaining high performance under load.</p>
<h2 id="the-core-architecture-dedicated-event-handler">The Core Architecture: Dedicated Event Handler</h2>
<p>Instead of forcing blocking operations into a generic event system, I designed a dedicated <code>ResponseEventHandler</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ResponseEventHandler</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mu</span>           <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">activeWaiters</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">responseWaiter</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nextWaiterID</span>  <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">responseWaiter</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">id</span>           <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">matcher</span>      <span style="color:#a6e22e">URLMatcher</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">responseChan</span> <span style="color:#66d9ef">chan</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Response</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>          <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cancel</span>       <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">CancelFunc</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This separation of concerns eliminates the complexity of generic handlers while providing exactly what blocking operations need: unique waiter identification, context-based lifecycle management, and efficient lookup patterns. Each waiter gets its own dedicated channel and context, making cleanup deterministic and race-free. Furthermore, it built ontop of the existing process in <code>k6</code> to handle browser events without relying on a generic structure.</p>
<figure><img src="/wait-for-response-architecture.png"
    alt="low coupling high cohesion" width="100%">
</figure>

<p>As you can see, we create channels for each waiter that will be notified once a processed browser event is seen to match against it.</p>
<h2 id="thread-safety-lock-free-notification-pattern">Thread Safety: Lock-Free Notification Pattern</h2>
<p>The key insight was separating read operations from write operations to minimize lock contention:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">reh</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ResponseEventHandler</span>) <span style="color:#a6e22e">processResponse</span>(<span style="color:#a6e22e">response</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Response</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">waiter</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">activeWaiters</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">waiter</span>.<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">matched</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">waiter</span>.<span style="color:#a6e22e">matcher</span>(<span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">URL</span>())
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">matched</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">waiter</span>.<span style="color:#a6e22e">responseChan</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">response</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">waiter</span>.<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This pattern allows high-concurrency reads while ensuring notifications happen outside the critical section. The non-blocking send prevents deadlocks when contexts are cancelled mid-notification, and the RWMutex optimizes for the common case of many concurrent response processors with fewer waiter registrations.</p>
<h2 id="resource-management-context-driven-cleanup">Resource Management: Context-Driven Cleanup</h2>
<p>Rather than manual cleanup tracking, the system leverages Go&rsquo;s context cancellation for automatic resource management:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Page</span>) <span style="color:#a6e22e">WaitForResponse</span>(<span style="color:#a6e22e">urlPattern</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">opts</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">WaitForResponseOptions</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Response</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithTimeout</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">opts</span>.<span style="color:#a6e22e">Timeout</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancel</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">matcher</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">urlMatcher</span>(<span style="color:#a6e22e">urlPattern</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;parsing URL pattern: %w&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">responseEventHandler</span>.<span style="color:#a6e22e">waitForMatch</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">matcher</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When the context expires or gets cancelled, cleanup happens automatically through the defer chain. No need to hunt for specific handler instances in slices or complex reflection logic. The waiter removes itself from the active map when its context completes, ensuring zero resource leaks even under high load or unexpected cancellations. We can find this explicitly in the <code>waitForMatch</code> function that recieves that page context and builds out the waiter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">reh</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ResponseEventHandler</span>) <span style="color:#a6e22e">waitForMatch</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">matcher</span> <span style="color:#a6e22e">URLMatcher</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Response</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waiterContext</span>, <span style="color:#a6e22e">waiterCancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waiter</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">responseWaiter</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">matcher</span>:      <span style="color:#a6e22e">matcher</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">responseChan</span>: make(<span style="color:#66d9ef">chan</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Response</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ctx</span>:          <span style="color:#a6e22e">waiterContext</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cancel</span>:       <span style="color:#a6e22e">waiterCancel</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Add waiter</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">id</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">nextWaiterID</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">activeWaiters</span>[<span style="color:#a6e22e">id</span>] = <span style="color:#a6e22e">waiter</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">waiterCancel</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Remove waiter</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>		delete(<span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">activeWaiters</span>, <span style="color:#a6e22e">id</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">reh</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">waiter</span>.<span style="color:#a6e22e">responseChan</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">response</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Err</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here, we use the higher level page context and listen for the context to cancel in a <code>select</code>. As soon as it&rsquo;s canceled, we lock the <code>activeWaiter</code> and safely remove it, or if a match is found through the Event Processing System, the waiter is also removed.</p>
<h2 id="real-world-testing-edge-cases-and-performance">Real-World Testing: Edge Cases and Performance</h2>
<p>Integration testing revealed several edge cases that the architecture handled gracefully. Concurrent timeouts with overlapping response patterns worked without interference. Context cancellation during high-volume response processing didn&rsquo;t cause goroutine leaks. The system maintained consistent performance with 100+ concurrent waiters, and memory usage remained stable over extended test runs. Code review feedback led to switching from buffered to unbuffered channels, eliminating potential synchronization smells and making the concurrency model clearer. The reviewer&rsquo;s attention to detail helped identify potential panic scenarios that were addressed through proper channel lifecycle management.</p>
<h2 id="key-takeaways-patterns-that-scale">Key Takeaways: Patterns That Scale</h2>
<p>Three main lessons emerged from this implementation.</p>
<ol>
<li>Dedicated data structures often outperform generic solutions in concurrent systems—the complexity savings and performance benefits justify the additional code.</li>
<li>Proper Go concurrency patterns (RWMutex for read-heavy workloads, context-based cancellation, non-blocking sends) prevent entire classes of bugs before they happen.</li>
<li>Resource lifecycle management becomes much simpler when you design for it upfront rather than retrofitting cleanup logic. Taking advantage of existing tools, such as Go&rsquo;s native <code>context</code>, is how you build reliable code.</li>
</ol>
<p>This approach improved maintainability significantly—the new code is easier to understand, debug, and extend. The pattern is now setup to be used across multiple k6 browser APIs where blocking operations are needed.</p>
<h2 id="impact-and-future-building-on-solid-foundations">Impact and Future: Building on Solid Foundations</h2>
<p>The PR was successfully merged into k6&rsquo;s, adding a critical piece of browser automation functionality that developers had been requesting. The thread-safe architecture enables reliable testing of applications with complex network timing requirements, particularly important for load testing scenarios where network conditions vary. This foundation also sets up future enhancements like predicate function support (<code>await page.waitForResponse(response =&gt; response.status() === 200)</code>) and more sophisticated filtering options. Most importantly, the architectural patterns demonstrated here—dedicated concurrent data structures, context-driven resource management, and lock-free notification systems—are applicable far beyond browser automation to any Go system that needs reliable event handling under concurrent load.</p>

            </div>
        </article>
    </div>
</div>


        </main>

        <footer>
            <div class="social-links">
                <a href="https://github.com/HasithDeAlwis">[ Github ]</a>
                <a href="mailto:hasithde24@gmail.com">[ Email ]</a>
                <a href="https://www.linkedin.com/in/hasith-de-alwis/">[ LinkedIn ]</a>
            </div>
            <div class="status-line">
                &copy; 2025 &gt; Hasith De Alwis -- Built with Hugo
            </div>
        </footer>
    </div>
</body>

</html>