<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on &gt; Hasith De Alwis</title>
    <link>http://localhost:1313/blog/</link>
    <description>Recent content in Blog on &gt; Hasith De Alwis</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Jul 2025 10:30:00 -0400</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AI Workflows, Ignore the Hype</title>
      <link>http://localhost:1313/blog/effective-ai-workflows/</link>
      <pubDate>Thu, 24 Jul 2025 10:30:00 -0400</pubDate>
      <guid>http://localhost:1313/blog/effective-ai-workflows/</guid>
      <description>&lt;h1 id=&#34;building-thread-safe-event-systems-in-go-a-k6-waitforresponse-case-study&#34;&gt;Building Thread-Safe Event Systems in Go: A k6 waitForResponse Case Study&lt;/h1&gt;&#xA;&lt;p&gt;Browser automation tools need to wait for specific network responsesâ€”but building this in a concurrent system is trickier than it looks. When testing web applications, you often need to wait for an API call to complete before proceeding with the next action. Without proper synchronization, tests become flaky and unreliable. Recently, I contributed the &lt;code&gt;waitForResponse&lt;/code&gt; API to k6&amp;rsquo;s browser module, architecting a thread-safe event system that handles hundreds of concurrent waiters without race conditions or resource leaks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Building Thread-Safe Event Systems in Go: A k6 waitForResponse Case Study</title>
      <link>http://localhost:1313/blog/thread-safe-event-systems-in-go/</link>
      <pubDate>Thu, 24 Jul 2025 10:30:00 -0400</pubDate>
      <guid>http://localhost:1313/blog/thread-safe-event-systems-in-go/</guid>
      <description>&lt;h1 id=&#34;building-thread-safe-event-systems-in-go-a-k6-waitforresponse-case-study&#34;&gt;Building Thread-Safe Event Systems in Go: A k6 waitForResponse Case Study&lt;/h1&gt;&#xA;&lt;p&gt;Browser automation tools need to wait for specific network responsesâ€”but building this in a concurrent system is trickier than it looks. When testing web applications, you often need to wait for an API call to complete before proceeding with the next action. Without proper synchronization, tests become flaky and unreliable. Recently, I contributed the &lt;code&gt;waitForResponse&lt;/code&gt; API to k6&amp;rsquo;s browser module, architecting a thread-safe event system that handles hundreds of concurrent waiters without race conditions or resource leaks.&lt;/p&gt;</description>
    </item>
    <item>
      <title>FE best practices</title>
      <link>http://localhost:1313/blog/fe-best-practices/</link>
      <pubDate>Sat, 28 Dec 2024 10:30:00 -0400</pubDate>
      <guid>http://localhost:1313/blog/fe-best-practices/</guid>
      <description>&lt;p&gt;&lt;strong&gt;DISCLAIMER:&lt;/strong&gt; As predicted, I disagree with a lot of what I wrote here earlier ðŸ˜…. With that being said, I still want to keep it up since there is still some useful information, and it&amp;rsquo;s always fun to see how far you&amp;rsquo;ve come.&lt;/p&gt;&#xA;&lt;p&gt;Scalable front-end code is an expansive topic; of course, there are topics I can&amp;rsquo;t cover here, such as effective testing, development philosophies, monorepos, and much more. This article focuses on practical strategies for scaling front-end code in terms of architecture, maintainability, and technologies. My primary goal is to leave you with an idea of WHAT you should be researching and looking into, not necessarily explaining the nitty-gritty of all topics. This guide is meant to be framework agnostic, and my advice here should be transferable to any framework.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
